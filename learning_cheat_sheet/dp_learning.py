# learning dinamic programming
'''Первое что будем рассматривать это задачу поиска числа фибоначи
Если n < 2 : n
иначе function(n-1) + function(n-2)
Меньше двух, так как при вызове 1 будет 1 при вызове двойки будет 1 + 0
'''

# def function(n):
#     if n < 2:
#         return n
#     return function(n-1) + function(n-2)
# n = int(input())
# print(function(n))


'''Но рекурсия не будет работать на больших числах так как мы дважды при поиске предыдущих элементов,
поэтому лучше сохранять их
'''

# n = int(input())
# dp = [0] * (n+1)
# dp[1] = 1
# for i in range(2,n + 1):
#     dp[i] = dp[i-1] + dp[i-2]
# print(dp[n])


"""
ПЛАН:
1) Состояние динамики(что именно считает рекурсивная функция / или что именно храниться в списке):
в первом примере это числа фибоначи
2) База динамики(в рекурсии это условия, в общем случае простые подазадачи - случаи когда мы можем посчитать ответ):
в первом примере это числа 0 и 1
3) Рекурентное соотношение(зависимость очередного решения, от решения подзадач)
4) Направление обхода(в каком порядке мы решаем подзадачи):
в первом способе мы проходили от 2-го числа до n
5) Где ответ?:
В первом случае это элемент массива с индексом n
"""
'''Теперь решим задачку о кузнечике, где кузнечик прыгает по кочкам, причем может прыгать через кочку
или просто на следющую кочку. Посчитать сколькими способами кузнечик смог допрыгать до n кочки?
Решение простое: на первую кочку можно одним способом, на вторую двумя, на третью со второй и с первой, 
следовательно 3 (1 + 2)
Решение это задачи аналогично поиску числа фибоначи
'''

# n = int(input())
# dp = [0] * (n+1)
# dp[1] = 1
# dp[2] = 2
# for i in range(3, n + 1):
#     dp[i] = dp[i-1] + dp[i-2]
# print(dp[n])


'''Задача:
Допустим у нас есть строитель который может строить бошню из черных и белых кирпичей
Сколько способов построить различных столбиков высотой n, чтобы подряд не стояло три черных кирпича?
План решения:
1) кол-во способов построить столбик высотой i
2) 1 - двумя способами, 2 - тремя способами
3) i белый можно поставить столько, сколько i - 1
   i черный можно поставить столько, сколько i - 1 заканчивающееся белым кирпичем => i - 2
4) i - ый элемент последовательности
'''

# n = int(input())
# dp = [0] * (n+1)
# dp[0] = 1
# dp[1] = 2
# for i in range(2,n + 1):
#     dp[i] = dp[i-1] + dp[i-2]
# print(dp[n])


'''Задача:
Автомат на котором две кнопки: одна увеличивает число в 2 раза, а другая добавляет к числу 1
Сколько способов получить из 1 число n
1) кол-во способов получить число n из 1
2) Для 1 -> 1
3) если нечетное то dp[i-1]
   ecли четное то dp[i/2] + dp[i - 1]
'''

# n = int(input())
# dp = [0] * (n + 1)
# dp[1] = 1
# for i in range(2, n + 1):
#     if i%2 == 0:
#         dp[i] = dp[i // 2] + dp[i - 1]
#     else:
#         dp[i] = dp[i - 1]
# print(dp[n])


'''Теперь реализуем динамику вперед'''

# n = int(input())
# dp = [0] * 2 * n
# dp[1] = 1
# for i in range(1, n):
#     dp[i + 1] += dp[i]
#     dp[i * 2] += dp[i]
# print(dp[n])


'''Задача: задача о кузнечике, но кузнечик может прыгать на такое количество кочек, которое введенно(k)
Решается аналогично задачи фибоначи
'''

# n = int(input())
# k = int(input())
# dp = [0] * (n+1)
# dp[0] = 1
# for i in range(1, n + 1):
#    for j in range(1,k+1):
#       if i - j >= 0:
#          dp[i] += dp[i - j]
# print(dp[n])


'''Задача: предыдущая задача, но на некоторых кочках есть лягушки, и попав на эти кочки кузнечик проигрывает
Кочки с лягушками вводятся списком
'''

# n = int(input())
# k = int(input())
# frogs = list(map(int,input().split()))
# dp = [0] * (n+1)
# dp[0] = 1
# for i in range(1, n + 1):
#    if i in frogs:
#       continue
#    for j in range(1,k+1):
#       if i - j >= 0:
#          dp[i] += dp[i - j]
# print(dp[n])


'''Задача: теперь обычная задача о кузнечике но кузнечик будет платить или получать деньги попадая на кочки
какую максимальную сумму может набрать кузнечик
Чтобы решить необзодимо понять, что попав в какую-то определенную точку мы получаем деньги  этой кочки, а также
нам необходим максимум из всех предыдущих кочек.
'''

# n = int(input())
# k = int(input())
# money = [0] + list(map(int,input().split()))
# dp = [0] * (n+1)
# for i in range(1, n + 1):
#    ans = - 10 ** 12
#    for j in range(1, k+1):
#       if i - j >= 0 and dp[i - j] > ans:
#          ans = dp[i - j]
#    dp[i] = money[i] + ans
# print(dp[n])


'''Задача: Совместим задачу денюшек и лягушек
'''

n = int(input())
k = int(input())
frogs = list(map(int,input().split()))
money = [0] + list(map(int,input().split()))
dp = [0] * (n+1)
for i in frogs:
   dp[i] = - 10 ** 12
for i in range(1, n + 1):
   ans = - 10 ** 12
   for j in range(1, k+1):
      if i - j >= 0 and dp[i - j] > ans:
         ans = dp[i - j]
   dp[i] = money[i] + ans
if dp[n] < - 10 ** 8:
   print('NO')
else:
   print('YES')
   print(dp[n])